{"name":"Sidekiq-ActiveRecord","tagline":"Sidekiq-ORM Project","body":"[Sidekiq::Activerecord](https://github.com/sidekiq-orm/sidekiq-activerecord) encapsulates common patterns and various interactions between [Sidekiq](https://github.com/mperham/sidekiq) and ActiveRecord.\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'sidekiq-activerecord'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n    \r\n# Common Patterns\r\nIf you've been using [Sidekiq](https://github.com/mperham/sidekiq) for a while, you've probably noticed a recurring pattern in your workers:\r\n\r\n# Sidekiq::ActiveRecord::TaskWorker\r\nA fairly common ```Sidekiq::Worker``` pattern, is a worker which does the following:\r\n```\r\n* Receives a model.id as it's argument.\r\n* Loads the specified model.\r\n* Verifies that the model exists.\r\n* Performs some additional validation.\r\n  (since the model may have changed since the worker was enqueued)\r\n* If all is well, runs some application logic on the mode.\r\n```\r\nlets checkout an example:\r\n```ruby\r\nclass UserTaskWorker\r\n  include Sidekiq::Worker\r\n\r\n  def perform(user_id)\r\n    user = User.find(user_id)\r\n    return unless user.present?\r\n    return unless user.active?\r\n\r\n    UserService.run(user)\r\n  end\r\n\r\nend\r\n```\r\n```Sidekiq::ActiveRecord::TaskWorker``` wraps this boilerplate and lets you access the model, using the ```perform_on_model``` method:\r\n\r\n\r\n```ruby\r\nclass UserTaskWorker < Sidekiq::ActiveRecord::TaskWorker\r\n\r\n  sidekiq_task_model :user # or User\r\n\r\n  def perform_on_model\r\n    current_user = task_model\r\n    UserService.run(current_user)\r\n  end\r\n  \r\nend\r\n```\r\nThe ```sidekiq_task_model``` is the task's model. it can be either a symbol (```:user```) or the model class (```User```).\r\nNote that ```perform_on_model``` will only be called if the model exist and valid. (more on that soon)\r\nIn case the task was called with additional arguments, will be passed to ```perform_on_model``` e.g: \r\n```ruby\r\nUserTaskWorker.perform_async(user.id, {:new_email => true})\r\n```\r\n```ruby\r\ndef perform_on_model(options)\r\n    UserService.run(task_model, options[:new_email])\r\nend\r\n```\r\nFor better readability, you can use an alias of ```task_model``` which is the same as name class name:\r\n```ruby\r\nsidekiq_task_model :user\r\n\r\ndef perform_on_model(service_options)\r\n    UserService.run(user, service_options)\r\nend\r\n```\r\n## Full Example\r\nCheckout the [full example](https://github.com/sidekiq-orm/sidekiq-activerecord/wiki/Task-Worker---Full-Example)\r\n\r\n# Hooks\r\nAdditionally, you can define the following methods which serve as hooks for each use-case:\r\n\r\n### Model not found\r\nAdd this method hook, which will be invoked in th event the model wasn't found. \r\n```ruby\r\ndef not_found_model(user_id)\r\n    Rails.logger.error \"User not found for ID:#{user_id}\"\r\nend\r\n```\r\n\r\n### Check the model before perform\r\nAdd this method hook, which will be invoked before the ```perform_on_model``` is called.\r\nIf the check fails, ```perform_on_model``` will not be called.\r\nWhen the method isn't defined, it returns ```true``` by default.\r\n```ruby\r\ndef should_perform_on_model?\r\n    task_model.active?\r\nend\r\n```\r\n\r\n### Model didn't pass the check\r\nAdd this method hook, which will be invoked in th event the model didn't pass the validation. \r\n```ruby\r\ndef did_not_perform_on_model\r\n    Rails.logger.error \"User #{task_model.id} is invalid\"\r\nend\r\n```\r\n\r\n## Hook Life Cycle\r\nThe hooks order of execution is:\r\n```\r\n* not_found_model\r\n* should_perform_on_model?\r\n* perform_on_model || did_not_perform_on_model\r\n```\r\n\r\n# Custom Task Options\r\nTo change the default task options, you can use the ```sidekiq_task_options``` to specify the following:\r\n\r\n#### identifier_key\r\nIn some cases the model identifier is not ```:id```.\r\nTo handle this, you can define the ```:identifier_key``` option:\r\n\r\n```ruby\r\nsidekiq_task_options :identifier_key => :token\r\n```\r\nWhich will load fetch the User by the ```:token``` attribute. \r\n\r\n<br>\r\n<br>\r\n***\r\n<br>\r\n\r\n# Sidekiq::ActiveRecord::ManagerWorker\r\nAnother farily common ```Sidekiq::Worker``` pattern, is a parent worker which goes over some model collection and enqueues a child worker for each model in the collection.\r\nlets checkout an example:\r\n\r\n```ruby\r\n# Parent Worker\r\nclass UserSyncer\r\n  include Sidekiq::Worker\r\n\r\n  def perform\r\n    User.active.each do |user|\r\n      ChildWorker.perform_async(user.id)\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n```ruby\r\n# Child Worker\r\nclass UserTaskWorker\r\n  include Sidekiq::Worker\r\n  \r\n  def perform(user_id)\r\n    # task logic\r\n  end\r\nend\r\n```\r\n```Sidekiq::ActiveRecord::ManagerWorker``` wraps this boilerplate with a clean DSL:\r\n```ruby\r\n# Parent Worker\r\nclass UserSyncer < Sidekiq::ActiveRecord::ManagerWorker\r\n  sidekiq_delegate_task_to :user_task_worker # or UserTaskWorker\r\nend\r\n```\r\nThen, just call the worker with the model collection:\r\n```ruby\r\nUserSyncer.perform_query_async(User.active)\r\n```\r\n\r\n## Delayed Execution\r\nLet's start with an example first:\r\n```ruby\r\nclass UserController < ApplicationController\r\n\r\n  def update\r\n    if current_user.update(update_params)\r\n       FriendRequestWorker.perform_query_async(current_user.friends)\r\n       UserSyncerWorker.perform_query_async(User.active)\r\n    end\r\n    respond_with current_user\r\n  end\r\n\r\nend\r\n```\r\nIn the above example, ```FriendRequestWorker``` will go over all the user's friends, which we can assume is a fairly medium size collection.\r\n\r\nAfter that, ```UserSyncerWorker``` will go over all of the ```User.active``` collection, which can be a huge collection, in large scale systems.\r\nIn such cases, when you don't to be blocking, it's recommended to delay the query execution as well. \r\n\r\nThe way this can be done, is to set the ```default_models_query``` in the ManagerWorker and calling ```perform_async```, which will run the specified query asynchronously: \r\n```ruby\r\nclass UserSyncerWorker < Sidekiq::ActiveRecord::ManagerWorker\r\n  sidekiq_delegate_task_to UserTaskWorker\r\n  default_models_query -> { User.active }\r\nend\r\n```\r\n```ruby\r\noverride_options = { :batch_size => 300 }\r\nUserSyncerWorker.perform_async(override_options)\r\n```\r\n\r\n## Configuration\r\n\r\n### batch_size\r\nDefault batch size is 1000\r\n```ruby\r\nsidekiq_manager_options :batch_size => 500\r\n```\r\n\r\n### identifier_key\r\nDefault identifier_key is ```:id```\r\n```ruby\r\nsidekiq_manager_options :identifier_key => :email\r\n```\r\n\r\n### additional_keys\r\nOther arguments to enqueue aside from the identifier\r\n```ruby\r\nsidekiq_manager_options :additional_keys => [:status, :username]\r\n```\r\n\r\n## Override default options\r\nJust pass the options to the manager:\r\n```ruby\r\noverride_options = {\r\n    :batch_size => 500,\r\n    :identifier_key => :user_token,\r\n    :additional_keys => [:status]\r\n}\r\nUserSyncer.perform_query_async(User.active, override_options)\r\n```\r\n","google":"UA-51556764-1","note":"Don't delete this file! It's used internally to help with page regeneration."}